#This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson

# Boiler Plate code
use base ("Understand::Codecheck");
use strict;

# This is the error that will be returned when a violation is found
use constant ERR1 => 'Unmodified pointer or reference parameter not declared as const';

# This registers ERR1 with Understand
sub register_tr_text() {
  my $check = shift;
  $check->add_tr_text(ERR1);
}

sub checkID { return "MISRA08_7-1-2";}


# This is the short error the Understand will use
sub name { return "7-1-2 A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the corresponding object is not modified";}

# This is the full description of the rule being tested
sub description { return "7-1-2 (Required) A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the corresponding object is not modified.";}

# This section returns the rational and examples to be given to the user through Understand
sub detailed_description { return <<"END_DESC"
<p><b>Rationale</b><br>
This rule leads to greater precision in the definition of the function interface. The <i>const</i> qualification
shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<br>
<p><b>Exception</b><br>
This rule does not apply if the parameter object is modified by any of the functions in a set of
overriding functions.</p>
<br>
<b>Example</b><pre style="margin-top:0;padding-top:0;">

  void myfunc(       int16_t *       param1,
               const int16_t *       param2,
                     int16_t *       param3,
                     int16_t * const param4)
  // param1: Addresses an object which is modified      - Compliant
  // param2: Addresses an object which is not modified  – Compliant
  // param3: Addresses an object which is not modified  – Non-compliant
  // param4: Addresses an object which is not modified  – Non-compliant
  {
    *param1 = *param2 + *param3 + *param4;
    // Data at address param3 and param4 have not been changed
  }

</pre>


END_DESC
}

# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language =~ /C\+\+/; #Handles C and C++
}

# This determines if this script is per file
sub test_entity { return 1;}

# This determines if this script is per project or per file
sub test_global { return 0;}

# Any defined options go here
sub define_options{
  my $check = shift;
  $check->option->checkbox( 'function', 'Treat parameters passed to another function as modified', 0 );
}


# This is the actual test being performed on the user's code
sub check {

  # Pull the name of the check and the name of the file from the incoming script request
  my $check = shift; 
  my $file = shift;
  my $exemptFunction = $check->option->lookup( 'function' );
  return unless $file->kind->check("c file");
  
  # Pull a list of all functions that are defined within this file
  my @objectsDefined = $file->filerefs("Define", "Parameter");
  return unless @objectsDefined;

  # Loop through each parameter that is defined
  OBJ : foreach my $object ( @objectsDefined ) {

    # If this paramter is used as a constructor initlization list, than these are not the droids we are looking for
    next OBJ if checkParam( $object );
    next OBJ if $object->ent->type !~ /\*|\&/;

    # Check if this parameter is a function pointer
    my $parem = $object->ent;
    my $parameterType = $parem->type;

    # Recursively check each type until we achieve base type
    while ( $parem->refs( 'C Typed' ) ) {
      $parem = $parem->ref( 'C Typed' )->ent;
      $parameterType = $parem->type;
    }

    next OBJ if $parameterType =~ /[^\(]+\(\s*\*\s*\)\s*\([^\)]*\)/;

    my $flag = 1;

    $flag = 0 if $object->ent->ref( 'Deref Setby, Setby, Modifyby' ) or checkUses( $object, $exemptFunction, $check );

    my $const = 1;

    # Keeping this comment here
    #$const = 0 if $object->ent->type =~ /\bconst\b/ and $object->ent->type !~ /\*\bconst\b/;
    $const = 0 if $object->ent->type =~ /^[^\*]*?\bconst\b/;

    if ( $flag and $const ) {

      # Get the parent and check if parent is overridden by anything
      my $parent = $object->ent->parent;

      my @overrides = $parent->refs( 'Overriddenby, Overrides' );
      foreach my $over ( @overrides ) {

        # Pull any define references from the overridding function
        my @overridesDefines = $over->ent->refs( 'Define', 'Parameter' );

        # Loop through each of the overriding parameters
        foreach my $overridden ( @overridesDefines ) {

          # Test of the variable is modified in the overriding function, if so, compliant by exception
          if ( $object->ent->name eq $overridden->ent->name and $overridden->ent->ref( 'Deref Setby, Setby, Modifyby' ) ) {

            $flag = 0;

          }
        }
      }
    }

    $check->violation( $object->ent, $file, $object->line, $object->column, ERR1 ) if $flag and $const;
  }
}


# This sub routine is designed to test if a parameter is used to set a datamember, if so, this parameter is exempt
sub checkParam {

  # Pull my object and create a lexeme for testing if use is within an init list or not
  my $object = shift;
  my $lexeme = $object->lexeme;
  $lexeme = $lexeme->nextUseful;

  # Walk forward until we find our use or the end of our init list
  while( $lexeme and $lexeme->text ne $object->ent->name and $lexeme->text ne '{' and $lexeme->text ne ';' ) {
    $lexeme = $lexeme->nextUseful;
  }

  # Return success if we found or use case within an init list
  return 0 unless $lexeme;
  return 1 if $object->ent->name eq $lexeme->text;
  return 0;

}


# This subroutine takes a parameter and checks use references to see if they are passed out of scope ( Trivial Cases only )
sub checkUses {

  # Pull my incoming parameter and all associated useby references
  my $parameter = shift;
  my $exemptFunction = shift;
  my $useFound = 0;
  my $check = shift;
  my @allUseBy = $parameter->ent->refs( 'C Useby' );

  foreach my $useBy ( @allUseBy ) {

    # Loop through each useBy reference and move backwards to detect form a = b
    my $lexeme = $useBy->lexeme( 1, 8, 1, 1 );

    $useFound = findFunctionUse( $lexeme, $check ) if $exemptFunction;

    while( ! ( $lexeme->text eq '=' or $lexeme->text eq '(' ) ) {
      $lexeme = $lexeme->prevUseful;
    }

    $lexeme = $lexeme->prevUseful;
    next unless $lexeme->ref;

    # Return success of we are setting a non const data member or non const global object
    $useFound = 1 if $lexeme->ref->scope->kind->check( 'C Object Member' ) and !( $lexeme->ref->scope->type =~ /^[^\*]*?\bconst\b/ );
    $useFound = 1 if $lexeme->ref->scope->kind->check( 'C Object Global' ) and !( $lexeme->ref->scope->type =~ /^[^\*]*?\bconst\b/ );

  }
  return $useFound;
}


sub findFunctionUse {

  my $lexeme = shift;
  my $check = shift;
  my $count = 1;
  my $useFound = 0;

  while( $lexeme and ! ( $count == 0 or $lexeme->text eq ';' ) ) {

    $count++ if $lexeme->text eq ')';
    $count-- if $lexeme->text eq '(';
    $lexeme = $lexeme->prevUseful;

  }
  
  if ( $lexeme and $lexeme->ref ) {
    $useFound = 1 if $lexeme->ref->scope->kind->check( 'C Function' );
  }

  return $useFound;


}