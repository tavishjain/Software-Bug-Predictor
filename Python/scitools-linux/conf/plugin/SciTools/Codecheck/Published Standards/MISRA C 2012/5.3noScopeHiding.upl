#This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson
# 10-1-14


# Boiler Plate code
use base ("Understand::Codecheck");
use strict;


# This is the error that will be returned when a violation is found
use constant ERR1 => 'Identifier "%1" possibly hiding outer definition from line %2';


# This registers ERR1 with Understand
sub register_tr_text {
  my $check = shift;
  $check->add_tr_text(ERR1);
}

sub checkID { return "MISRA12_5.3";}



# This is the short error the Understand will use
sub name{
  return '5.3 An identifier declared in an inner scope shall not hide an identifier declared in an outer scope';
}


# This is the full description of the rule being tested
sub description {
  return "5.3 ( Required ) An identifier declared in an inner scope shall not hide an identifier declared in an outer scope.";
}


# This section returns the rational and examples to be given to the user through Understand
sub detailed_description {
  return  <<"END_DESC"

<p><b>Amplification</b><br>
An identifier declared in an inner scope shall be distinct from any identifier declared in an outer scope.
</p>

<p>
The definition of distinct depends on the implementation and the version of the C language that is
being used:
</p>

<p>
• In C90 the minimum requirement is that the first 31 characters are significant;
</p>

<p>
• In C99 the minimum requirement is that the first 63 characters are significant, with each
universal character or extended source character counting as a single character.
</p>

<p><b>Rationale</b><br>
If two identifiers differ only in non-significant characters, the behaviour is undefined.
</p>

<p>
If an identifier is declared in an inner scope but is not distinct from an identifier that already exists in
an outer scope, then the inner-most declaration will “hide” the outer one. This may lead to developer
confusion.
</p>

<p>
<i>Note</i>: An identifier declared in one name space does not hide an identifier declared in a different name
space.
</p>

<p>
The terms outer and inner scope are defi ned as follows:
</p>

<p>
• Identifiers that have file scope can be considered as having the outermost scope;
</p>

<p>
• Identifiers that have block scope have a more inner scope;
</p>

<p>
• Successive, nested blocks, introduce more inner scopes.
</p>

<p><b>Example</b><br>
</p>

<pre style="margin-top:0;padding-top:0;">

  void fn1 ( void )
  {
    int16_t i;                            /* Declare an object "i" */
    {
      int16_t i;                          /* Non-compliant - hides previous "i " */
      i = 3;                              /* Could be confusing as to which "i" this refers */
    }
  }

  struct astruct
  {
    int16_t m;
  };

  extern void g ( struct astruct *p );

  int16_t xyz = 0; /* Declare an object "xyz" */

  void fn2 ( struct astruct xyz )         /* Non-compliant - outer "xyz" is
                                           * now hidden by parameter name */
    {
      g ( &xyz );
    }

  uint16_t speed;

  void fn3 ( void )
  {
    typedef float32_t speed;              /* Non-compliant - type hides object */
  }

</pre>

<p><b>See also</b><br>
Rule 5.2, Rule 5.8
</p>

END_DESC
}


# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language eq "C++";
}


# This determines if this script is per file
sub test_entity {
  return 1;
}


# This determines if this script is per project or per file
sub test_global {
  return 0;
}


# Any defined options go here
sub define_options{
  my $check = shift;
  $check->option->checkbox( 'C99', 'Use C99 standard? ( C90 default )', 0 );
}


sub check {

  # Pull check and file from Understand. Test that we are looking at a file and return otherwise
  my $check = shift; 
  my $file = shift; 
  return unless $file->kind->check("file ~unknown ~unresolved");
  
  # Start my hash for tracking patterns
  my %patternsSeen = ();

  # Start lexer, we have to walk through the whole file
  my $lexer = $file->lexer(1,0,0);
  return unless $lexer;
  my $lexeme = $lexer->first();

  # Start our descent into recursivsivsivsiv....
  checkScope ( $check, $file, $lexeme, \%patternsSeen );

}


# Subroutine to get the length of significant characters
sub getLength {

  # Set the length of the string to be tested based off the user selected option
  my $check = shift;
  my $length;
  if  ( $check->option->lookup( 'C99' ) ) {
    $length = 63;
  } else {
    $length = 31
  }
  return $length

}


# Create a sub string of length of significant characters
sub makeSubstring {

  # Create the substring of the entity name to compare to other entities
  my $check = shift;
  my $name = shift;
  my $subString = substr ( $name, 0, getLength( $check ) );
  return $subString;

}


# Subroutine for recursively checking scopes
sub checkScope {

  # Pull everything from the calling function
  my $check = shift;
  my $file = shift;
  my $lexeme = shift;
  my $patternsReference = shift;
  my %patternsSeen = %$patternsReference;
  my %patternsSeenThisLevel = ();
  my %parametersSeen = ();
  my $for = 0;

  # While we still have a valid lexeme
  LEX : while ( $lexeme ) {
    #Yield to GUI interupts
    $check->yield();
    return if $check->is_abort();
    
    # Check if we need to go up a level
    if ( $lexeme->token eq 'Punctuation' && $lexeme->text eq '}' ) {

      return $lexeme;

    # Check if we need to go down a level
    } elsif ( $lexeme->token eq 'Punctuation' && $lexeme->text eq '{' ) {

      $lexeme = $lexeme->nextUseful;
      
      my %combinedPatterns = ( %patternsSeen, %patternsSeenThisLevel, %parametersSeen );
      $lexeme = checkScope ( $check, $file, $lexeme, \%combinedPatterns );
      %parametersSeen = ();
      $for = 0;

    # If we see for or while loop, handle conditional statement
    } elsif ( $lexeme->token eq 'Keyword' && $lexeme->text eq 'for' ) {

      $for = 1;

    # If we see an identifier, add it to our hash
    } elsif ( $lexeme->token eq 'Identifier' ) {

      # Get our string and entity
      my $subString = $lexeme->text;
      my $ref = $lexeme->ref;

      # Unless we are looking at a define reference, we don't care
      unless ( $ref and ( $ref->kindname eq 'Define' or $ref->kindname eq 'Init' ) ) {
        
        $lexeme = $lexeme->nextUseful;
        next LEX;

      }


      if ( exists $patternsSeen{ $subString } ) {

        # We've seen this entity before
        my $seenRef = $patternsSeen{ $subString };

        # If we are looking at a class union or struct, we have to do an additional check to ensure it's not a constructor or destructor
        my $flag = 0;
        if (  $seenRef->ent->kind->longname =~/\bType\b/ or $seenRef->scope->kind->longname =~/\bType\b/ ) {

          my $type = 0;
          $type = $seenRef->ent if $seenRef->ent->kind->longname =~/\bType\b/;
          $type = $seenRef->scope if $seenRef->scope->kind->longname =~/\bType\b/;
          $flag = 1 if $type->longname eq $ref->scope->parent->longname;
          
        }


        $check->violation( $ref->scope, $ref->file, $ref->line, $ref->column, ERR1, $ref->scope->name, $seenRef->line ) unless $flag;

      } elsif ( $ref->scope->kindname =~ /\bParameter\b/ and exists $patternsSeenThisLevel{ $subString } ) {

        # Special case because technically parameters are defined before the block they are considered a part of
        my $seenRef = $patternsSeenThisLevel{ $subString };
        $check->violation( $ref->scope, $ref->file, $ref->line, $ref->column, ERR1, $ref->scope->name, $seenRef->line );
        $parametersSeen{ $subString } = $ref;
        


      } else {

        if ( $ref->scope->kindname =~ /\bParameter\b/ || $for ) {
          $parametersSeen{ $subString } = $ref;
        } else {
          $patternsSeenThisLevel{ $subString } = $ref;
        }
        

      }

    }

    return unless $lexeme;
    $lexeme = $lexeme->nextUseful if $lexeme;

  }
}


