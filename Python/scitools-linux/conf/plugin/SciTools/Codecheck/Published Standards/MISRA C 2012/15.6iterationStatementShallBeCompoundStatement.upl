# This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson
# 8-19-15


# Boiler Plate code
use base ( 'Understand::Codecheck' );
use strict;


# This is the error that will be returned when a violation is found
use constant ERR1 => 'Iteration-statement or selection-statement not a compound-statement';


# This registers ERR1 with Understand
sub register_tr_text {

  my $check = shift;
  $check->add_tr_text(ERR1);

}

sub checkID { return "MISRA12_15.6";}



# This is the short error the Understand will use
sub name{
  return '15.6 The body of an iteration-statement or a selection-statement shall be a compound-statement';
}


# This is the full description of the rule being tested
sub description {
  return '15.6 ( Required ) The body of an iteration-statement or a selection-statement shall be a compound-statement.';
}


# This section returns the rational and examples to be given to the user through Understand
sub detailed_description {
  return  <<"END_DESC"

<p><b>Amplification</b><br>
The body of an iteration-statement (while, do â€¦ while or for) or a selection -statement (if, else, switch) shall
be a compound-statement.
</p>

<p><b>Rationale</b><br>
It is possible for a developer to mistakenly believe that a sequence of statements forms the body of
an iteration-statement or <em>selection-statement</em> by virtue of their indentation. The accidental inclusion of a
semi-colon after the controlling expression is a particular danger, leading to a null control statement.
Using a <em>compound-statement</em> clearly defines which statements actually form the body.
</p>

<p>
Additionally, it is possible that indentation may lead a developer to associate an <em>else</em> statement with
the wrong <em>if</em>.
</p>

<p><b>Exception</b><br>
An if statement immediately following an else need not be contained within a compound-statement.
</p>

<p><b>Example</b><br>
The layout for the compound-statement and its enclosing braces are style issues which are not
addressed by this document; the style used in the following examples is not mandatory.
</p>

<p>
Maintenance to the following
</p>

<pre style="margin-top:0;padding-top:0;">

  while ( data_available )
    process_data ( ); /* Non-c ompliant */

</pre>

<p>
could accidentally give
</p>

<pre style="margin-top:0;padding-top:0;">

  while ( data_available )
    process_data ( ); /* Non-compliant */
    service_watchdog ( );

</pre>

<p>
where service_watchdog() should have been added to the loop body. The use of a <em>compound-statement</em>
significantly reduces the chance of this happening.
</p>

<p>
The next example appears to show that action_2() is the <em>else</em> statement to the first <em>if</em>.
</p>

<pre style="margin-top:0;padding-top:0;">

  if ( flag_1 )
    if ( flag_2 ) /* Non-compliant */
      action_1 ( ); /* Non-compliant */
  else
    action_2 ( ); /* Non-compliant */

</pre>

<p>
when the actual behaviour is
</p>

<pre style="margin-top:0;padding-top:0;">

  if ( flag_1 )
  {
    if ( flag_2 )
    {
      action_1 ( );
    }
    else
    {
      action_2 ( );
    }
  }

</pre>

<p>
The use of <em>compound-statements</em> ensures that <em>if</em> and <em>else</em> associations are clearly defined.
The exception allows the use of <em>else if</em>, as shown below
</p>

<pre style="margin-top:0;padding-top:0;">

  if ( flag_1 )
  {
    action_1 ( );
  }
  else if ( flag_2 ) /* Compliant by exception */
  {
    action_2 ( );
  }
  else
  {
    ;
  }

</pre>

<p>
The following example shows how a spurious semi-colon could lead to an error
</p>

<pre style="margin-top:0;padding-top:0;">

  while ( flag ); /* Non-compliant */
  {
    flag = fn ( );
  }

</pre>

<p>
The following example shows the compliant method of writing a loop with an empty body:
</p>

<pre style="margin-top:0;padding-top:0;">

  while ( !data_available )
  {
  }

</pre>

END_DESC
}


# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language eq "C++";
}


# This determines if this script is run per file
sub test_entity {
  return 1;
}


# This determines if this script is run on the whole project
sub test_global {
  return 0;
}


# Any defined options go here
sub define_options {
}


# This subroutine will recursively test iteration statments
sub iterationTest {

  # Pull my arguements
  my $function = shift;
  my $lexeme = shift;
  my $check = shift;
  my $file = shift;
  my $doFlag = shift;
  my $errorLocation = $lexeme;

  # Test for else if clause, if so, we don't want to double test
  if ( $lexeme->text eq 'else' and $lexeme->nextUseful->text eq 'if' ) {
    $lexeme = $lexeme->nextUseful;
  }

  # Move through parentheses if this iteration test is not a do .. while
  if ( $lexeme->text !~ /do|else/ ) {

    # Find first parentheses
    while ( $lexeme->text ne '(' ) {
      $lexeme = $lexeme->nextUseful;
    }

    # Setup tracking variables
    $lexeme = $lexeme->nextUseful;
    my $count = 1;

    # Move to the start of our iteration-statement 
    while ( $count > 0 ) {
      $count++ if $lexeme->text eq '(';
      $count-- if $lexeme->text eq ')';
      $lexeme = $lexeme->nextUseful;
    }

  } else {
    $lexeme = $lexeme->nextUseful;
  }



  # Find beginned of iteration-statement
  while ( $lexeme->text ne '{' and $lexeme->text ne ';' ) {

    $lexeme = iterationTest( $function, $lexeme, $check, $file, 0 ) if $lexeme->token eq 'Keyword' and $lexeme->text =~ /\bwhile\b|\bfor\b|\bif\b|\bswitch\b|\belse\b/;
    $lexeme = iterationTest( $function, $lexeme, $check, $file, 1 ) if $lexeme->token eq 'Keyword' and $lexeme->text =~ /\bdo\b/;

    $lexeme = $lexeme->nextUseful;

  }

  # If we find a semi-colon before we find an open curly brace, we know we have an error
  $check->violation( $function->ent, $file, $errorLocation->line_begin, $errorLocation->column_begin, ERR1 ) if $lexeme->text eq ';' and ! $doFlag;
  return $lexeme;

}


# This is the actual test being performed on the user's code
sub check {

  # Pull the name of the check and the name of the file from the incoming script request
  my $check = shift; 
  my $file = shift;
  return unless $file->kind->check( 'C File' );
  
  # Pull a list of all functions that are defined within this file
  my @functionsDefined = $file->filerefs( 'C Define', 'C Function' );
  return unless @functionsDefined;
  
  # loop through all defined functions
  foreach my $function ( @functionsDefined ) {
    
    # Pull text of function
    my $text = $function->ent->contents;
    # Remove any // style comments
    $text =~ s/\/\/.*?\n/\n/g;
    # Remove any /* */ style comments
    $text =~ s/\/\*.*?\*\//\n/gs;
    # check if a loop statement exists
    next unless $text =~/\bwhile\b|\bfor\b|\bif\b|\bswitch\b|\bdo\b/;

    # Spin up lexer to find goto statement
    my $lexeme = $function->lexeme();
    my $doFlag = 0;

    # Check entire function
    my $end = $function->ent->ref('end')->line;
    while ( $lexeme->line_begin < $end ) {

      # When we see one of our test cases
      if ( $lexeme->token eq 'Keyword' and $lexeme->text =~ /\bwhile\b|\bfor\b|\bdo\b|\bif\b|\bswitch\b|\belse\b/ ) {
        
        $doFlag = 1 if $lexeme->text eq 'do';
        $lexeme = iterationTest( $function, $lexeme, $check, $file, $doFlag );

      }
      $lexeme = $lexeme->nextUseful;
    }
  }
}