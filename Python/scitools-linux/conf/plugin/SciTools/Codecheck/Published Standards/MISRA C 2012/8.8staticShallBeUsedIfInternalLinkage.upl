# This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson
# This code was copied from MISRA 2004 rule 8.11
# 1-15-15


# Boiler Plate code
use base ( 'Understand::Codecheck' );
use strict;


# This is the error that will be returned when a violation is found
use constant ERR1 => '%1 "%2" appears to have internal linkage within %3, so static keyword should be used.';


# This registers ERR1 with Understand
sub register_tr_text {
  my $check = shift;
  $check->add_tr_text(ERR1);
}

sub checkID { return "MISRA12_8.8";}



# This is the short error the Understand will use
sub name{
  return '8.8 The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage';
}


# This is the full description of the rule being tested
sub description {
  return '8.8 (Global)(Required) The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage.';
}


# This section returns the rational and examples to be given to the user through Understand
sub detailed_description {
  return  <<"END_DESC"

<p><b>Amplification</b><br>
Since definitions are also declarations, this rule applies equally to definitions.
</p>

<p><b>Rationale</b><br>
The Standard states that if an object or function is declared with the extern storage class specifier
and another declaration of the object or function is already visible, the linkage is that specified by the
earlier declaration. This can be confusing because it might be expected that the extern storage class
specifier creates external linkage. The static storage class specifier shall therefore be consistently
applied to objects and functions with internal linkage.
</p>

<p><b>Example</b><br>
</p>

<pre style="margin-top:0;padding-top:0;">

  static int32_t x = 0;       /* definition: internal linkage   */
  extern int32_t x;           /* Non-compliant                  */

  static int32_t f ( void );  /* declaration: internal linkage  */
  int32_t f ( void )          /* Non-compliant                  */
  {
    return 1;
  }

  static int32_t g ( void );  /* declaration: internal linkage  */
  extern int32_t g ( void )   /* Non-compliant                  */
  {
    return 1;
  }

</pre>


END_DESC
}


# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language eq "C++";
}


# This determines if this script is run per file
sub test_entity {
  return 0;
}


# This determines if this script is run on the whole project
sub test_global {
  return 1;
}


# Any defined options go here
sub define_options {
}


sub checkKind {
  my ($check, $kind) = @_;
  
  my $db = $check->db;
  
  my $refString = 'define';
  my $kindString = $kind . ' ~static ~Member';
  
  my %seen;
  FILE: foreach my $file ($check->get_files) {

    next FILE unless $file->kind->check('c file');

    REF: foreach my $ref ($file->filerefs($refString, $kindString, 0)) {

      my $ent = $ref->ent;
      next REF if $ent->name eq 'main';
      
      foreach my $otherRef ($ent->refs) {
        next REF if $otherRef->file->uniquename ne $file->uniquename;
      }
      
      $check->violation($ent, $ref->file, $ref->line, $ref->column, ERR1, $kind, $ent->longname, $ref->file->name);

    }

  }
  
  return;
}


sub check {

  my $check = shift;
  
  checkKind($check, 'C Global Object');
  checkKind($check, 'C Function');
  
  return;
}