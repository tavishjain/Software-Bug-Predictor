#This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson
# 10-10-14


# Boiler Plate code
use base ("Understand::Codecheck");
use strict;


# This is the error that will be returned when a violation is found
use constant ERR1 => 'Violation: tag "%1" reused.';
use constant ERR2 => 'Violation: %1 "%2" used as %3.';


# This registers ERR1 with Understand
sub register_tr_text {
  my $check = shift;
  $check->add_tr_text(ERR1);
  $check->add_tr_text(ERR2);
}

sub checkID { return "MISRA12_5.7";}



# This is the short error the Understand will use
sub name{
  return '5.7 A tag name shall be a unique identifier';
}


# This is the full description of the rule being tested
sub description {
  return "5.7 (Global)( Required ) A tag name shall be a unique identifier.";
}


# This section returns the rational and examples to be given to the user through Understand
sub detailed_description {
  return  <<"END_DESC"

<p><b>Amplification</b><br>
The tag shall be unique across all name spaces and translation units.
</p>

<p>
All declarations of the tag shall specify the same type.
</p>

<p>
Multiple complete declarations of the same tag are only permitted by this rule if the tag is declared in
a <i>header file</i> and that <i>header file</i> is included in multiple source files.
</p>

<p><b>Rationale</b><br>
Reusing a tag name may lead to developer confusion.
</p>

<p>
There is also undefined behaviour associated with reuse of tag names in C90 although this is not
listed in The Standard's Annex. This undefined behaviour was recognized in C99 as a constraint in
Section 6.7.2.3.
</p>

<p><b>Exception</b><br>
The tag name may be the same as the typedef name with which it is associated.
</p>

<p><b>Example</b><br>
</p>

<pre style="margin-top:0;padding-top:0;">

  struct stag
  {
    uint16_t a;
    uint16_t b;
  };

  struct stag a1 = { 0, 0 };  /* Compliant - compatible with above */
  union stag a2 = { 0, 0 };   /* Non-compliant - declares different type
                               * from struct stag.
                               * Constraint violation in C99 */

</pre>

<p>
The following example also violates Rule 5.3
</p>

<pre style="margin-top:0;padding-top:0;">

  struct deer
  {
    uint16_t a;
    uint16_t b;
  };

  void foo ( void )
  {
    struct deer
    {
      uint16_t a;
    };                    /* Non-compliant - tag "deer" reused */
  }

  typedef struct coord
  {
    uint16_t x;
    uint16_t y;
  } coord;                /* Compliant by Exception */

  struct elk
  {
    uint16_t x;
  };

  struct elk              /* Non-compliant - declaration of different type
                           * Constraint violation in C99 */
  {
    uint32_t x;
  };

</pre>

<p><b>See also</b><br>
Rule 5.6
</p>

END_DESC
}


# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language eq "C++";
}


# This determines if this script is per file
sub test_entity {
  return 0;
}


# This determines if this script is per project or per file
sub test_global {
  return 1;
}


# Any defined options go here
sub define_options{
}


# This is the actual test being performed on the user's code
sub check {
  my $check = shift;
  my $db = $check->db;
  
  my %seen;
  my %errors;
  foreach my $file ($check->get_files()) {
    next unless $file->kind->check('c file');
    foreach my $ref ($file->filerefs('define', 'c union, c struct', 0)) {
      if (defined $seen{$ref->ent->name} && $ref->ent->name !~ "[unnamed]") {
        $check->violation($ref->ent, $file, $ref->line, $ref->column, ERR1, $ref->ent->name);
        $errors{$ref->ent->name}++;
        
        if ($errors{$ref->ent->name} == 2) {
          my $ref2 = $seen{$ref->ent->name};
          $check->violation($ref2->ent, $ref2->file, $ref2->line, $ref2->column, ERR1, $ref2->ent->name);
        }
      }
      else {
        $seen{$ref->ent->name} = $ref;
        $errors{$ref->ent->name} = 1;
      }
    }
  }
  foreach my $file ($check->get_files()) {
    foreach my $ref ($file->filerefs('define, declare', 'function ~member, object', 0)) {
      if (defined $seen{$ref->ent->name}) {
        $check->violation($ref->ent, $file, $ref->line, $ref->column, ERR1, $ref->ent->name);
      }
    }
    foreach my $ref ($file->filerefs('define, declare', 'function member', 0)) {
      next if checkConstructorOrDestructor($ref->ent->parent, $ref->ent);
      if (defined $seen{$ref->ent->name}) {
        $check->violation($ref->ent, $file, $ref->line, $ref->column, ERR1, $ref->ent->name);
      }
    }
    
    foreach my $ref ($file->filerefs('~define', 'c object', 1)) {
      foreach my $name (keys  %seen) {
        next unless $ref->ent->type =~ m/\b$name\b/x;
        if ($seen{$name}->ent->kindname =~ m/ struct /ix && $ref->ent->type =~ m/\b union \s+(\S+) \b/x) {
          $check->violation($ref->ent, $ref->file, $ref->line, $ref->column, ERR2, 'struct', $1, 'union');
        }
      }
    }
    foreach my $ref ($file->filerefs('~define', 'c object', 1)) {
      foreach my $name (keys  %seen) {
        next unless $ref->ent->type =~ m/\b$name\b/x;
        if ($seen{$name}->ent->kindname =~ m/ union /ix && $ref->ent->type =~ m/\b struct \s+(\S+) \b/x) {
          $check->violation($ref->ent, $ref->file, $ref->line, $ref->column, ERR2, 'union', $1, 'struct');
        }
      }
    }
  }
  
  return;
}

sub checkConstructorOrDestructor {
    my $class = shift;
    my $ent = shift;
    return ( ( $class->name() eq $ent->name() ) or ( $ent->name() eq '~' . $class->name() ) );
}