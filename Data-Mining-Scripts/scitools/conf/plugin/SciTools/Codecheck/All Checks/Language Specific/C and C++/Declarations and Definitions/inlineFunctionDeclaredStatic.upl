# This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson
# 1-15-15


# Boiler Plate code
use base ( 'Understand::Codecheck' );
use strict;


# This is the error that will be returned when a violation is found
use constant ERR1 => '%1 is declared inline but is not static.';


# This registers ERR1 with Understand
sub register_tr_text {
  my $check = shift;
  $check->add_tr_text(ERR1);
}


# This is the short error the Understand will use

sub checkID { return "CPP_D017";}

sub name{
  return 'An inline function shall be declared with the static storage class';
}


# This is the full description of the rule being tested
sub description {
  return '( Required ) An inline function shall be declared with the static storage class.';
}


# This section returns the rational and examples to be given to the user through Understand
sub detailed_description {
  return  <<"END_DESC"

<p><b>Rationale</b><br>
If an <i>inline function</i> is declared with external linkage but not defined in the same translation unit, the
behaviour is undefined.
</p>

<p>
A call to an <i>inline function</i> declared with external linkage may call the external definition of the function,
or it may use the inline definition. Although this should not affect the behaviour of the called function,
it might affect execution timing and therefore have an impact on a real-time program.
</p>

<p>
<i>Note</i>: an <i>inline function</i> can be made available to several translation units by placing its definition in a
header file.
</p>

<p><b>See also</b><br>
Rule 5.9
</p>


END_DESC
}


# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language eq "C++";
}


# This determines if this script is run per file
sub test_entity {
  return 1;
}


# This determines if this script is run on the whole project
sub test_global {
  return 0;
}


# Any defined options go here
sub define_options{
  my $check = shift;
  $check->option->checkbox( 'declare', 'Ignore function declarations?', 0 );
}



# This is the actual test being performed on the user's code
sub check {

  # Pull the name of the check and the name of the file from the incoming script request
  my $check = shift;
  my $file = shift;
  return unless $file->kind->check( 'C File' );

  # Pull all functions
  my @functionsDefined;

  # Check to see if we are ignoring function declarations
  if ( $check->option->lookup( 'declare' ) ) {
    @functionsDefined = $file->filerefs( 'C Define', 'Function ~Static ~Unknown ~Unresolved ~Template ~Member' ); 
  } else {
    @functionsDefined = $file->filerefs( 'C Define, C Declare', 'Function ~Static ~Unknown ~Unresolved ~Template ~Member' );
  }
  return unless @functionsDefined;

  # Check each function for the inline keyword, throw error if found
  foreach my $function ( @functionsDefined ) {

    # Skip operator overloads
    next if $function->ent->name =~ /operator(\+|\-|\*|\/|\%|\^|\&|\||\~|\!|\=|\<|\>|\+\=|\-\=|\*\=|\/\=|\&\=|\|\=|\<\<|\>\>|\<\<\=|\>\>\=|\=\=|\!\=|\<\=|\>\=|\&\&|\|\||\+\+|\-\-|\,|\-\>\*|\-\>|\(\)|\[\])/;

    my $lexeme = $function->lexeme;
    while ( $lexeme and $lexeme->text ne 'inline' and $lexeme->text ne ';' ) {
      $lexeme = $lexeme->prevUseful;
    }
    next unless $lexeme;

    $check->violation( $function->ent, $function->file, $function->line, $function->column, ERR1, $function->ent->name ) if $lexeme->text eq 'inline';

  }
}