# This script is designed to run with Understand - CodeCheck
# Rewritten by Kyle Jackson
# 8/13/2015

# Boiler Plate code
use base ("Understand::Codecheck");
use strict;

# This is the error that will be returned when a violation is found
use constant ERR1 => 'Loop counter %1 may be modified';
use constant ERR2 => 'Loop counter %1 is being modified';

# This registers ERR1 with Understand
sub register_tr_text() {
  my $check = shift;
  $check->add_tr_text( ERR1 );
  $check->add_tr_text( ERR2 );
}

# This is the short error the Understand will use

sub checkID { return "CPP_C022";}

sub name { return "The loop-counter shall not be modified within condition or statement";}

# This is the full description of the rule being tested
sub description { return "The loop-counter shall not be modified within condition or statement.";}

# This section returns the rational and examples to be given to the user through Understand
sub detailed_description { return <<"END_DESC"

<p><b>Developer's Note</b><br>
This check can only test Loop count variables defined within the instantiation of the for loop.
</loopl>

<p><b>Rationale</b><br>
Modification of the <i>loop-counter</i> other than in <i>expression</i> leads to a badly-formed <i>for</i> loop.</p>
<br>
<b>Example</b><pre style="margin-top:0;padding-top:0;">
  bool modify ( int32_t * pX )
  {
    *pX++;
    return ( *pX < 10 );
  }
  for ( x = 0; modify ( &x ); ) // Non-compliant
  {
  }
  for ( x = 0; x < 10; )
  {
    x = x * 2; // Non-compliant
  }
</pre>


END_DESC
}

# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language =~ /C\+\+/; #Handles C and C++
}

# This determines if this script is per file
sub test_entity { return 1;}

# This determines if this script is per project or per file
sub test_global { return 0;}

# Any defined options go here
sub define_options{
}


# This function tests contents of one for loop
sub testLoop {

  my $lexeme = shift;
  my $function = shift;
  my $check = shift;

  # Move into for loop structure
  $lexeme = $lexeme->nextUseful();
  $lexeme = $lexeme->nextUseful();

  # Check the first parameter to the for loop
  my %init = ();
  while ( $lexeme->text ne ';' ) {

    # We don't want to test a namespace or class, only data member
    if ( $lexeme->next && $lexeme->next->text eq ':' && $lexeme->next->next->text eq ':' ) {

      $lexeme = $lexeme->next;
      $lexeme = $lexeme->next;
      $lexeme = $lexeme->next;

    } elsif ( $lexeme->next && $lexeme->next->text eq ':' && $lexeme->next->next->text ne ':' ) {
      return $lexeme;
    }

    $init{ $lexeme->ent->name } = $lexeme->ent if $lexeme->token eq 'Identifier' and $lexeme->nextUseful->text eq '=' and $lexeme->ent;
    $lexeme = $lexeme->next;

  }    


  # Check the condition to the for loop
  $lexeme = $lexeme->nextUseful;
  
  while ( $lexeme->text ne ';' ) {

    if ( $lexeme->ref ) {
      if ( exists $init{ $lexeme->ent->name } && $lexeme->ref->kind->check( 'Addr Useby' ) ) {
        $check->violation( $lexeme->ent, $lexeme->ref->file, $lexeme->ref->line, $lexeme->ref->column, ERR1, $lexeme->ent->name );
      } elsif ( exists $init{ $lexeme->ent->name } && $lexeme->ref->kind->check( 'Setby, Modifyby' ) ) {
        $check->violation( $lexeme->ent, $lexeme->ref->file, $lexeme->ref->line, $lexeme->ref->column, ERR2, $lexeme->ent->name );
      }
    }

    $lexeme = $lexeme->next;

  }    


  # Check the third parameter to the for loop
  while ( $lexeme->text ne ')' ) {
    $lexeme = $lexeme->nextUseful;
  }


  my $startLine = $lexeme->line_begin;
  my $startColumn = $lexeme->column_begin;

  # There is no for loop block
  if ( $lexeme->nextUseful->text ne '{' ) {
    
    while ( $lexeme->text ne ';' ) {

      $lexeme = testLoop( $lexeme, $function, $check ) if ( $lexeme->token eq 'Keyword' and $lexeme->text eq 'for');
      $lexeme = $lexeme->next;

    }


  # There is a standard loop block
  } else {

    while ( $lexeme->text ne '{' ) {
      $lexeme = $lexeme->nextUseful;
    }
    $lexeme = $lexeme->nextUseful;

    my $count = 1;

    # Test for nexted for loops
    while ( $count > 0 ) {

      $lexeme = testLoop( $lexeme, $function, $check ) if ( $lexeme->token eq 'Keyword' and $lexeme->text eq 'for');
      $count++ if $lexeme->text eq '{';
      $count-- if $lexeme->text eq '}';

      $lexeme = $lexeme->next;

    }  
  }

  # Get end markers
  my $endLine = $lexeme->line_begin;
  my $endColumn = $lexeme->column_begin;

  # Check each identifier within init for proper usage
  foreach my $term( values %init ) {

    next if $term->type =~ /\bconst\b\w+/;

    # Not guarenteed that the value is changed, but it is possible
    my @useRefs = $term->refs( 'Addr Useby' );
    foreach my $ref( @useRefs ) {

      if ( ( $ref->line > $startLine || $ref->line == $startLine && $ref->column >= $startColumn ) && 
           ( $ref->line < $endLine || $ref->line == $endLine && $ref->column <= $endColumn ) ) {
        $check->violation( $term, $ref->file, $ref->line, $ref->column, ERR1, $term->name );
      }
    }

    # Value has changed
    my @setRefs = $term->refs( 'Setby, Modifyby' );
    foreach my $ref( @setRefs ) {

      if ( ( $ref->line > $startLine || $ref->line == $startLine && $ref->column >= $startColumn ) && 
           ( $ref->line < $endLine || $ref->line == $endLine && $ref->column <= $endColumn ) ) {
        $check->violation( $term, $ref->file, $ref->line, $ref->column, ERR2, $term->name );
      }
    }
  }

  return $lexeme;
}



# This is the actual test being performed on the user's code
sub check {

  # Pull the name of the check and the name of the file from the incoming script request
  my $check = shift; 
  my $file = shift;
  return unless $file->kind->check('c file');
  
  # Pull a list of all functions that are defined within this file
  my @functionsDefined = $file->filerefs( 'Define', 'Function');
  return unless @functionsDefined;
  
  # loop through all defined functions
  foreach my $function( @functionsDefined ) {
    
    # Pull text of function
    my $text = $function->ent->contents;
    # Remove any // style comments
    $text =~ s/\/\/.*?\n/\n/g;
    # Remove any /* */ style comments
    $text =~ s/\/\*.*?\*\//\n/gs;
    # check if a for loop exists
    next unless $text =~/for\s*\(/;

    # Spin up lexer and find for loop
    my $lexeme = $function->lexeme();

    # Check entire function
    my $end = $function->ent->ref( 'end' )->line;
    LINE : while ( $lexeme->line_begin < $end ) {

      # Test a for loop
      if ( $lexeme->token eq 'Keyword' and $lexeme->text eq 'for') {
        $lexeme = testLoop( $lexeme, $function, $check );
      } else {
        $lexeme = $lexeme->nextUseful;
      }

    }
  }
}