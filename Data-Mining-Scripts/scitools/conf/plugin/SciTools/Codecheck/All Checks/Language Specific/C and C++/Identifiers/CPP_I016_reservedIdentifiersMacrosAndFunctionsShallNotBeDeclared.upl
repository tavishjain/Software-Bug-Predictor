#This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson

# Boiler Plate code
use base ("Understand::Codecheck");
use strict;

# This is the error that will be returned when a violation is found
use constant ERR1 => 'Reserved Identifier, Macro, or Function declared in file %1';

# This registers ERR1 with Understand
sub register_tr_text() {
  my $check = shift;
  $check->add_tr_text(ERR1);
}

sub checkID { return "CPP_I016";}


# This is the short error the Understand will use
sub name { return "A reserved identifier or macro name shall not be declared";}

# This is the full description of the rule being tested
sub description { return "(Required) A reserved identifier or macro name shall not be declared.";}

# This section returns the rational and examples to be given to the user through Understand
sub detailed_description { return <<"END_DESC"

<p><b>Rationale</b><br>
The implementation is permitted to rely on reserved identifiers behaving as described in The Standard
and may treat them specially. If reserved identifiers are reused, the program may exhibit undefined
behaviour.
</p>


<b>Example</b><pre style="margin-top:0;padding-top:0;">
	In the following non-compliant example, the function memcpy is declared explicitly. The compliant
	method of declaring this function is to include <string.h>.

	/*
	 * Include <stddef.h> to define size_t
	 */
	#include <stddef.h>
	extern void *memcpy ( void *restrict s1, const void *restrict s2, size_t n );

	An implementation is permitted to provide a function-like macro definition for each Standard Library
	function in addition to the library function itself. This feature is often used by compiler writers to
	generate efficient inline operations in place of the call to a library function. Using a function-like macro,
	the call to a library function can be replaced with a call to a reserved function that is detected by the
	compiler’s code generation phase and replaced with the inline operation. For example, the fragment
	of <math.h> that declares sqrt might be written using a function-like macro that generates a call to
	_BUILTIN_sqrt which is replaced with an inline SQRT instruction on processors that support it:

	extern double sqrt ( double x );

	#define sqrt( x ) ( _BUILTIN_sqrt ( x ) )

	The following non-compliant code might interfere with the compiler’s built-in mechanism for handling
	sqrt and therefore produce undefined behaviour:

	#define _BUILTIN_sqrt( x ) ( x ) 	/* Non-compliant */
	#include <math.h>

	float64_t x = sqrt ( ( float64_t ) 2.0 ); /* sqrt may not behave as
	 										  * defined in The Standard */
</pre>


END_DESC
}

# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language =~ /C\+\+/; #Handles C and C++
}

# This determines if this script is per file
sub test_entity { return 1;}

# This determines if this script is per project or per file
sub test_global { return 0;}

# Any defined options go here
sub define_options{}

# Use this function for throwing errors
sub throwError {
  my $check = shift;
  my $ent = shift;
  my $file = shift;
  my $line = shift;
  my $column = shift;
  my $error = shift;
  my $name = shift;
  $check->violation($ent,$file,$line,$column,$error,$name);
}

# This is the actual test being performed on the user's code
sub check {
  # Pull the name of the check and the name of the file from the incoming script request
  my $check = shift; 
  my $file = shift;
  return unless $file->kind->check("c file");
  
  #define my array of reserved keywords
  my @reservedNames = ("abort", "abs", "acos", "asctime", "asin", "atan", "atan2", "atexit", 
                       "atof", "atoi", "atol", "bsearch", "btowc", "calloc", "ceil", "clearerr", 
					   "clock", "cos", "cosh", "ctime", "difftime", "div", "exit", "exp", "fabs", 
					   "fclose", "feof", "ferror", "fflush", "fgetc", "fgetpos", "fgets", 
					   "fgetwc", "fgetws", "floor", "fmod", "fopen", "fprintf", "fputc", "fputs", 
					   "fputwc", "fputws", "fread", "free", "freopen", "frexp", "fscanf", "fseek", 
					   "fsetpos", "ftell", "fwide", "fwprintf", "fwrite", "fwscanf", "getc", 
					   "getchar", "getenv", "gets", "getwc", "getwchar", "gmtime", "isalnum", 
					   "isalpha", "iscntrl", "isdigit", "isgraph", "islower", "isprint", 
					   "ispunct", "isspace", "isupper", "iswalnum", "iswalpha", "iswcntrl", 
					   "iswctype", "iswdigit", "iswgraph", "iswlower", "iswprint", "iswpunct", 
					   "iswspace", "iswupper", "iswxdigit", "isxdigit", "labs", "ldexp", "ldiv", 
					   "localeconv", "localtime", "log", "log10", "longjmp", "malloc", "mblen", 
					   "mbrlen", "mbrtowc", "mbsinit", "mbsrtowcs", "mbstowcs", "mbtowc", "memchr", 
					   "memcmp", "memcpy", "memmove", "memset", "mktime", "modf", "perror", "pow", 
					   "printf", "putc", "putchar", "puts", "putwc", "putwchar", "qsort", "raise", 
					   "rand", "realloc", "remove", "rename", "rewind", "scanf", "setbuf", 
					   "setlocale", "setvbuf", "signal", "sin", "sinh", "sprintf", "sqrt", "srand", 
					   "sscanf", "strcat", "strchr", "strcmp", "strcoll", "strcpy", "strcspn", 
					   "strerror", "strftime", "strlen", "strncat", "strncmp", "strncpy", "strpbrk", 
					   "strrchr", "strspn", "strstr", "strtod", "strtok", "strtol", "strtoul", 
					   "strxfrm", "swprintf", "swscanf", "system", "tan", "tanh", "time", "tmpfile", 
					   "tmpnam", "tolower", "toupper", "towctrans", "towlower", "towupper", "ungetc", 
					   "ungetwc", "vfprintf", "vfwprintf", "vprintf", "vsprintf", "vswprintf", 
					   "vwprintf", "wcrtomb", "wcscat", "wcschr", "wcscmp", "wcscoll", "wcscpy", 
					   "wcscspn", "wcsftime", "wcslen", "wcsncat", "wcsncmp", "wcsncpy", "wcspbrk", 
					   "wcsrchr", "wcsrtombs", "wcsspn", "wcsstr", "wcstod", "wcstok", "wcstol", 
					   "wcstombs", "wcstoul", "wcsxfrm", "wctob", "wctomb", "wctrans", "wctype", 
					   "wmemchr", "wmemcmp", "wmemcpy", "wmemmove", "wmemset", "wprintf", "wscanf", 
					   "assert", "BUFSIZ", "CLOCKS_PER_SEC", "EDOM", "EOF", "ERANGE", "errno", 
					   "EXIT_FAILURE", "EXIT_SUCCESS", "FILENAME_MAX", "HUGE_VAL", "LC_ALL", 
					   "LC_COLLATE", "LC_CTYPE", "LC_MONETARY", "LC_NUMERIC", "LC_TIME", "L_tmpnam", 
					   "MB_CUR_MAX", "NULL", "FOPEN_MAX", "offsetof", "RAND_MAX", "SEEK_CUR", 
					   "SEEK_END", "SEEK_SET", "setjmp", "SIGTERM", "SIG_DFL", "SIG_ERR", "SIG_IGN", 
					   "stderr", "stdin", "SIGABRT", "SIGILL", "SIGINT", "SIGSEGV", "WCHAR_MAX", 
					   "WCHAR_MIN", "WEOF", "WEOF", "_IOFBF", "_IOLBF", "stdout", "SIGFPE", "va_arg", 
					   "va_end", "va_start", "_IONBF", "TMP_MAX", "alignas", "alignof", "and", 
					   "and_eq", "asm", "auto", "bitand", "bitor", "bool", "break", "case", "catch", 
					   "char", "char16_t", "char32_t", "class", "compl", "const", "constexpr", 
					   "const_cast", "continue", "decltype", "default", "delete", "do", "double", 
					   "dynamic_cast", "else", "enum", "explicit", "export", "extern", "false", 
					   "float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable", 
					   "namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or", 
					   "or_eq", "private", "protected", "public", "register", "reinterpret_cast", 
					   "return", "short", "signed", "sizeof", "static", "static_assert", "static_cast", 
					   "struct", "switch", "template", "this", "thread_local", "throw", "true", "try", 
					   "typedef", "typeid", "typename", "union", "unsigned", "using", "virtual", "void", 
					   "volatile", "wchar_t", "while", "xor", "xor_eq","defined");
  
  # Loop through all macros and check the defines and undefs against the black list
  my @funcrefs = $file->filerefs("Declare, Define", "", 1); 
  foreach my $ref(@funcrefs) {
  	
  	# Special case to detect when a range based loop is used
  	if ( $ref->ent->name =~ /__begin|__end|__range/ ) {
  		my $define = $ref->ent->ref( 'Definein' );
  		my $set = $ref->ent->ref( 'Setby Init' );
  		my $use = $ref->ent->ref( 'Useby' );
  		if ( $define && $set && $use ) {
  			next if $define->line == $set->line && $set->line == $use->line;
  		}
  	}
  	
	throwError($check, $ref->ent,$file,$ref->line,$ref->column,ERR1,$file->name) if $ref->ent->name =~ /^_[A-Z]{1}.*$/;
	throwError($check, $ref->ent,$file,$ref->line,$ref->column,ERR1,$file->name) if $ref->ent->name =~ /^__.*$/;
	my $name = $ref->ent->name;
	throwError($check, $ref->ent, $file, $ref->line,$ref->column,ERR1,$file->name) if grep {/^\Q$name\E$/} @reservedNames;
  }
}
