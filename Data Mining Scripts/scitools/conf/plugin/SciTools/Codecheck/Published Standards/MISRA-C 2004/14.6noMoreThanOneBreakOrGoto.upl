# This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson
# 9-25-15


# Boiler Plate code
use base ( 'Understand::Codecheck' );
use strict;


# This is the error that will be returned when a violation is found
use constant ERR1 => 'More than one break or goto in loop iteration statment';
use constant ERR2 => 'Irregular loop construction, cannot test loop.';
use constant ERR3 => 'Unresolved label %1, cannot test this goto statement.';


# This registers ERR1 with Understand
sub register_tr_text {

  my $check = shift;
  $check->add_tr_text(ERR1);

}

sub checkID { return "MISRA04_14.6";}



# This is the short error the Understand will use
sub name{
  return '14.6 For any iteration statement there shall be at most one break statement used for loop termination.';
}


# This is the full description of the rule being tested
sub description {
  return '14.6 ( Required ) For any iteration statement there shall be at most one break statement used for loop termination.';
}


# This section returns the rational and examples to be given to the user through Understand
sub detailed_description {
  return  <<"END_DESC"

<p><b>Rationale</b><br>
These rules are in the interests of good structured programming. One break statement is allowed
in a loop since this allows, for example, for dual outcome loops or for optimal coding.
</p>

<p><b>Devloper's Note</b><br>
Goto statements with labels outside the loop body have been added to this check as we feel that 
given the intentions of this check, a goto statement would also allow for exit from a loop and 
should be treated the same as a break
</p>

<p><b>Example</b><br>
Both of the following nested loops are compliant as each has a single break used for early loop
termination.
</p>

<pre style="margin-top:0;padding-top:0;">

  for ( x = 0; x < LIMIT; ++x )
  {
    if ( ExitNow ( x ) )
    {
      break;
    }
    for ( y = 0; y < x; ++y )
    {
      if ( Exit Now ( LIMIT - y ) )
      {
        break;
      }
    }
  }

</pre>

<p>
The following loop is non-compliant as there are multiple break and goto statements used for early
loop termination.
</p>

<pre style="margin-top:0;padding-top:0;">

  for ( x = 0; x < LIMIT; ++x )
  {
    if ( BreakNow ( x ) )
    {
      break;
    }
    else if ( GotoNow ( x ) )
    {
      goto EXIT;
    }
    else
    {
      KeepGoing ( x );
    }
  }

  EXIT:
    ;

</pre>

<p>
In the following example, the inner while loop is compliant because there is a single goto statement
that can cause its early termination. However, the outer while loop is non-compliant because it can be
terminated early either by the break statement or by the goto statement in the inner while loop.
</p>

<pre style="margin-top:0;padding-top:0;">

  while ( x != 0u )
  {
    x = calc_new_x ( );

    if ( x == 1u )
    {
      break;
    }

    while ( y != 0u )
    {
      y = calc_new_y ( );
      if ( y == 1u )
      {
        goto L1;
      }
    }
  }

  L1:
  z = x + y;

</pre>

<p><b>See also</b><br>
Rule 15.1, Rule 15.2, Rule 15.3
</p>

END_DESC
}


# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language eq "C++";
}


# This determines if this script is run per file
sub test_entity {
  return 1;
}


# This determines if this script is run on the whole project
sub test_global {
  return 0;
}


# Any defined options go here
sub define_options {
}


# This function moves through the instantiation of do, while and for loops
sub enterLoop {

  # Pull in my parameters
  my $check = shift;
  my $function = shift;
  my $lexeme = shift;

  # Are we looking at a Do while?
  if ( lc ( $lexeme->text ) eq 'do' ) {

    $lexeme = $lexeme->nextUseful;

  # We are either looking at a for loop or a while loop
  } else {

    $lexeme = $lexeme->nextUseful;
    $lexeme = $lexeme->nextUseful;
    my $paren = 1;

    my $errorLexeme = $lexeme;
    while ( $paren > 0 ) {

      $paren++ if $lexeme->text eq '(';
      $paren-- if $lexeme->text eq ')';
      $lexeme = $lexeme->nextUseful;
      $check->violation( $function->ent, $function->file, $errorLexeme->line_begin, $errorLexeme->column_begin, 'Strangness here' ) unless $lexeme;

    }
  }

  return $lexeme;
}


# Use this function for each time we see a for, do or while loop
sub checkLoop {

  # Pull in my parameters
  my $check = shift;
  my $function = shift;
  my $lexeme = shift;

  # We found a loop, set anchor for potential errors and enter the loop body
  my $errorAnchor = $lexeme;

  # Create list of Goto's to check
  my $start = $lexeme->line_begin;
  my @gotos;

  $lexeme = enterLoop( $check, $function, $lexeme );

  # Are we looking at a block or a single line
  while ( !( $lexeme->text eq '{' or $lexeme->text eq ';' ) ) {
    $lexeme = $lexeme->nextUseful;
  }
  return if $lexeme->text eq ';';
  $lexeme = $lexeme->nextUseful;

  # Initialize my variables needed for tracking loop conclusion and exit counts
  my $count = 1;
  my $exits = 0;

  # Special case for if we see a switch statement
  my $switchCount = 0;
  my $inSwitch = 0;

  # Special case for nested loops
  my $loopCount = 0;
  my $inNestedLoop = 0;

  while ( $lexeme and $count > 0 ) {
    
    my $toCompare = lc ( $lexeme->text );
    if ( $lexeme->token eq 'Keyword' and $toCompare eq 'switch' ) {

      while ( $lexeme->text ne '{' ) {
        $lexeme = $lexeme->nextUseful;
      }
      $lexeme = $lexeme->nextUseful;
      $switchCount++;
      $count++;
      $loopCount++ if $inNestedLoop;
      $inSwitch = 1;

    }

    # Check nested loop to see if it's a single iteration statement, track if not
    if ( $lexeme->token eq 'Keyword' and $toCompare =~ /\bwhile\b|\bfor\b|\bdo\b/ ) {

      my $tempLexeme = enterLoop( $check, $function, $lexeme );
      
      while ( !( $tempLexeme->text eq '{' or $tempLexeme->text eq ';' ) ) {
        $tempLexeme = $tempLexeme->nextUseful;
      }

      if ( $tempLexeme->text eq '{' ) {

        $loopCount++;
        $count++;
        $switchCount++ if $inSwitch;
        $inNestedLoop = 1;
        $lexeme = $tempLexeme->nextUseful;

      }
      
    }

    # Test expected loop opening curly brace
    unless ( $lexeme ) {
      $check->violation( $errorAnchor->ent, $function->file, $errorAnchor->line_begin, $errorAnchor->column_begin, ERR2 );
      return;
    }

    $inSwitch = 0 if $switchCount == 0;
    $inNestedLoop = 0 if $loopCount == 0;

    # Track progression through loop
    $count++ if $lexeme->text eq '{';
    $count-- if $lexeme->text eq '}';

    # Track progression through switch
    $switchCount++ if $lexeme->text eq '{' and $inSwitch;
    $switchCount-- if $lexeme->text eq '}' and $inSwitch;

    # Track progression through nested loop
    $loopCount++ if $lexeme->text eq '{' and $inNestedLoop;
    $loopCount-- if $lexeme->text eq '}' and $inNestedLoop;

    # Loop for keywords that need to be counted
    $exits++ if $toCompare eq 'break' and $inSwitch == 0 and $inNestedLoop == 0;

    # Add to list to check later
    if ( $lexeme->token eq 'Keyword' and $toCompare eq 'goto' ) {
      unless ( $lexeme->nextUseful->ent ) {
        $check->violation( $errorAnchor->ent, $function->file, $errorAnchor->line_begin, $errorAnchor->column_begin, ERR3, $errorAnchor->nextUseful->text );
      } else {
        push( @gotos, $lexeme->nextUseful->ent );
      }
    }

    # Move to next iteration
    $lexeme = $lexeme->nextUseful;

  }

  # Test expected loop closing curly brace
  unless ( $lexeme ) {
    $check->violation( $errorAnchor->ent, $function->file, $errorAnchor->line_begin, $errorAnchor->column_begin, ERR2 );
    return;
  }

  # Loop through all found goto statements to see if they are used as exits
  foreach my $goto ( @gotos ) {

    
    my $label = $goto->ref( 'Definein' );
    $label = $goto->ref( 'Declarein' ) unless $label;
    
    if ( $label->line < $start or $label->line >= $lexeme->line_begin ) {
      $exits++;
    }
  }

  #Check exits and throw error if it is too high
  $check->violation( $errorAnchor->ent, $function->file, $errorAnchor->line_begin, $errorAnchor->column_begin, ERR1 ) if $exits > 1;
  return;
}


# This is the actual test being performed on the user's code
sub check {

  # Pull the name of the check and the name of the file from the incoming script request
  my $check = shift; 
  my $file = shift;
  return unless $file->kind->check( 'C File' );
  
  # Pull a list of all functions that are defined within this file
  my @functionsDefined = $file->filerefs( 'C Define', 'C Function' );
  return unless @functionsDefined;
  
  # loop through all defined functions
  FNC : foreach my $function ( @functionsDefined ) {
    
    # Pull text of function
    my $text = $function->ent->contents;
    # Remove any // style comments
    $text =~ s/\/\/.*?\n/\n/g;
    # Remove any /* */ style comments
    $text =~ s/\/\*.*?\*\//\n/gs;

    next FNC unless $text =~/\bwhile\s*\(/ or $text =~ /\bfor\s*\(/;

    # Spin up lexer to find loops
    my $lexeme = $function->lexeme();

    # Check entire function
    my $end = $function->ent->ref( 'end' )->line;
    while ( $lexeme->line_begin < $end ) {

      # check to see if we are the start of a loop
      my $toCompare = lc ( $lexeme->text );
      if( $lexeme->token eq 'Keyword' and lc( $lexeme->text ) =~ /\bwhile\b|\bfor\b|\bdo\b/ ) {

        checkLoop( $check, $function, $lexeme );
        $lexeme = $lexeme->nextUseful;

      } else {

        $lexeme = $lexeme->nextUseful;

      }
    }
  }
}