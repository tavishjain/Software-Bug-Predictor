# This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson
# 10-16-14


# Boiler Plate code
use base ( 'Understand::Codecheck' );
use strict;


# This is the error that will be returned when a violation is found
use constant ERR1 => 'Octal constant %1 used';


# This registers ERR1 with Understand
sub register_tr_text {
  my $check = shift;
  $check->add_tr_text(ERR1);
}

sub checkID { return "MISRA12_7.1";}



# This is the short error the Understand will use
sub name{
  return '7.1 Octal constants shall not be used';
}


# This is the full description of the rule being tested
sub description {
  return "7.1 ( Required ) Octal constants shall not be used.";
}


# This section returns the rational and examples to be given to the user through Understand
sub detailed_description {
  return  <<"END_DESC"

<p><b>Rationale</b><br>
Developers writing constants that have a leading zero might expect them to be interpreted as decimal
constants.
</p>

<p>
<i>Note</i>: this rule does not apply to octal escape sequences because the use of a leading \\ character 
means that there is less scope for confusion.
</p>

<p><b>Exception</b><br>
The integer constant zero (written as a single numeric digit), is strictly speaking an octal constant, but
is a permitted exception to this rule..
</p>

<p><b>Example</b><br>
</p>

<pre style="margin-top:0;padding-top:0;">

  extern uint16_t code[ 10 ];

  code[ 1 ] = 109; /* Compliant - decimal 109 */
  code[ 2 ] = 100; / * Compliant - decimal 100 */
  code[ 3 ] = 052; /* Non-Compliant - decimal 42 */
  code[ 4 ] = 071; /* Non-Compliant - decimal 57 */

</pre>

<p><b>Developer's Note</b><br>
This check can hang on extremely large files ( e.g. Over 300,000 lines ). If this occurs, please remove that
file from the list of files to be checked.
</p>

END_DESC
}


# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language eq "C++";
}


# This determines if this script is per file
sub test_entity {
  return 1;
}


# This determines if this script is per project or per file
sub test_global {
  return 0;
}


# Any defined options go here
sub define_options{}


# This is the actual test being performed on the user's code
sub check {

  my $check = shift;
  my $file = shift;
  return unless $file->kind->check( 'file' );
  return unless $file->contents =~ /0[0-9]+/;
  
  my $lexer = $file->lexer( 0 );
  my @lexemes = $lexer->lexemes if $lexer;
  
  foreach my $lexeme ( @lexemes ){
    #Yield to GUI interupts
    $check->yield();
    return if $check->is_abort();
    
    next unless $lexeme->token eq 'Literal';
    $check->violation( 0, $file, $lexeme->line_begin, $lexeme->column_begin, ERR1, $lexeme->text ) if $lexeme->text =~ /^0[0-9]+$/;

  }
}
