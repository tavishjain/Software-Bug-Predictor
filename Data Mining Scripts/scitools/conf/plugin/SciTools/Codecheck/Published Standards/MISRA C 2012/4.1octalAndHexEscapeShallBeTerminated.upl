#This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson
# 9-22-14


# Boiler Plate code
use base ("Understand::Codecheck");
use strict;


# This is the error that will be returned when a violation is found
use constant ERR1 => "Octal or hexadecimal escape sequence not terminated when setting %1";


# This registers ERR1 with Understand
sub register_tr_text {
  my $check = shift;
  $check->add_tr_text(ERR1);
}

sub checkID { return "MISRA12_4.1";}



# This is the short error the Understand will use
sub name{
  return '4.1 Octal and hex adecimal escape sequences shall be terminated';
}


# This is the full description of the rule being tested
sub description {
  return "4.1 ( Required ) Octal and hex adecimal escape sequences shall be terminated.";
}


# This section returns the rational and examples to be given to the user through Understand
sub detailed_description {
  return  <<"END_DESC"

<p><b>Amplification</b><br>
An octal or hexadecimal escape sequenc e shall be terminated by either:<br>
• The start of another escape sequence, or<br>
• The end of the character constant or the end of a string literal.<br>
</p>


<p><b>Rationale</b><br>
There is potential for confusion if an octal or hexadecimal escape sequence is followed by other
characters. For example, the character constant '\\x1f' consists of a single character whereas the
character constant '\\x1g' consists of the two characters '\\x1' and 'g'. The manner in which
multi-character constants are represented as integers is implementation-defined.</p>

<p>
The potential for confusion is reduced if every octal or hexadecimal escape sequence in a character
constant or string literal is terminated.</p>

<p><b>Example</b><br>
In this example, each of the strings pointed to by s1, s2 and s3 is equivalent to "Ag".
</p>

<pre style="margin-top:0;padding-top:0;">

  const char *s1 = "\\x41g";      /* Non-compliant */
  const char *s2 = "\\x41" "g";   /* Compliant - terminated by end of literal */
  const char *s3 = "\\x41\\x67";  /* Compliant - terminated by another escape */
  int c1 = '\\141t';              /* Non-compliant */
  int c2 = '\\141\\t';            /* Compliant - terminated by another escape */

</pre>

<p><b>See Also</b><br>
C90: Section 6.1.3.4, C99: Section 6.4.4.4</p>

END_DESC
}


# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language eq "C++";
}


# This determines if this script is per file
sub test_entity {
  return 1;
}


# This determines if this script is per project or per file
sub test_global {
  return 0;
}


# Any defined options go here
sub define_options{}


# Use this function for testing the validity of octal and hex constants
sub checkString {

  # Pull the text and the flag to know if this is hex or octal
  my $lexemeText = shift;
  my $isHex = shift;

  # Remove ' and " characters
  $lexemeText =~ s/\'//g;
  $lexemeText =~ s/\"//g;

  # Split each string on the escape charater '\'
  my @subStrings = split /\\/, $lexemeText;
  SUB : foreach my $sub ( @subStrings ) {

    # Move on if we have created an empty string
    next SUB if $sub eq '';

    # Use the flag to determine the check and set our return flag accordingly
    my $ok = 0;
    if ( $isHex ) {

      $ok = 1 if $sub =~ /^x[0-9a-fA-F]{1,3}$/;
      $ok = 1 if $sub =~ /^x[^0-9a-fA-F]{1,}$/;

    } else {

      $ok = 1 if $sub =~ /^[0-8]{1,3}$/;
      $ok = 1 if $sub =~ /^[^0-8]{1,3}$/;

    }
    
    return $ok;

  }
  
  # This is a special case for strings that are escaped ' or "
  return 1;
}


# This is the actual test being performed on the user's code
sub check {

  # Pull the name of the check and the name of the file from the incoming script request
  my $check = shift;
  my $file = shift;
  return unless $file->kind->check('file');
  
  # Pull all the set references, return if none
  my @setRefs = $file->filerefs( 'Set', 'Object');
  return unless @setRefs;

  # Loop through each set reference
  foreach my $set ( @setRefs ) {

    # Spin up lexer and test all strings between here and the semi colon
    my $lexeme = $set->lexeme;
    while ( $lexeme and $lexeme->text ne ';' ) {
      #Yield to GUI interupts
      $check->yield();
      return if $check->is_abort();
    
      # Test hex literals
      if ( $lexeme->token eq 'String' and $lexeme->text =~ /^[\'\"]\\x/ ) {

        my $ok = checkString ( $lexeme->text, 1 );
        $check->violation( $set->ent, $set->file, $set->line, $set->column, ERR1, $set->ent->name ) unless $ok;

      # Text octal literals
      } elsif ( $lexeme->token eq 'String' and $lexeme->text =~ /^[\'\"]\\/ ) {

        my $ok = checkString ( $lexeme->text, 0 );
        $check->violation( $set->ent, $set->file, $set->line, $set->column, ERR1, $set->ent->name ) unless $ok;

      }
      $lexeme = $lexeme->nextUseful;

    }
  }
}
