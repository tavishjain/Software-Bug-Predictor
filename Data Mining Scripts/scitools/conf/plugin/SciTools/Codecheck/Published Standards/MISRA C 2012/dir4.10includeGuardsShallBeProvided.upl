# This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson
# 12-5-14


# Boiler Plate code
use base ("Understand::Codecheck");
use strict;


# This is the error that will be returned when a violation is found
use constant ERR1 => 'Include guards not used in file';
use constant ERR2 => 'endif not last element of file';
use constant ERR3 => 'Macro used for include guard is not unique';


# This registers ERR1 with Understand
sub register_tr_text() {
  my $check = shift;
  $check->add_tr_text(ERR1);
  $check->add_tr_text(ERR2);
}

sub checkID { return "MISRA12_4.10";}



# This is the short error the Understand will use
sub name { 
  return 'Directive 4.10 Precautions shall be taken in order to prevent the contents of a header file being included more than once';
}


# This is the full description of the rule being tested
sub description { 
  return 'Directive 4.10 ( Required ) Precautions shall be taken in order to prevent the contents of a header file being included more than once.';
}


# This section returns the rational and examples to be given to the user through Understand
sub detailed_description { return <<"END_DESC"

<p><b>Rationale</b><br>
When a translation unit contains a complex hierarchy of nested header files, it is possible for a particular
header file to be included more than once. This can be, at best, a source of confusion. If this multiple
inclusion leads to multiple or conflicting definitions, then this can result in undefined or erroneous
behaviour.
</p>

<p><b>Example</b><br>
</p>

<pre style="margin-top:0;padding-top:0;">

  /* file.h */
  #ifndef FILE_H
  /* Non-co mpliant - does not #define FILE_H */
  #endif

</pre>

<p>
In order to facilitate checking, the contents of the header should be protected from being included
more than once using one of the following two forms:
</p>

<pre style="margin-top:0;padding-top:0;">

  <start-of-file>
  #if !defined ( identifier )
  #define identifier
    /* Contents of file */
  #endif
  <end-of-file>

  <start-of-file>
  #ifndef identifier
  #define identifier
    /* Contents of file */
  #endif
  <end-of-file>

</pre>

<p>
<i>Note</i>: the identifier used to test and record whether a given <i>header file</i> has already been included shall
be unique across all <i>header files</i> in the project.
</p>

<p>
<i>Note</i>: comments are permitted anywhere within these forms.
</p>

END_DESC
}


# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language =~ /C\+\+/; #Handles C and C++
}


# This determines if this script is per file
sub test_entity { 
  return 1;
}


# This determines if this script is per project or per file
sub test_global { 
  return 0;
}


# Any defined options go here
sub define_options{

}


# This subroutine checks for the ifndef include guard
sub includeGuard {

  my $lexeme = shift;
  my $check = shift;

  if ( lc ( $lexeme->text ) eq 'if' ) {

    $lexeme = $lexeme->nextUseful;
    return 0 unless $lexeme->text eq '!';
    $lexeme = $lexeme->nextUseful;
    return 0 unless lc ( $lexeme->text ) eq 'defined';

  } elsif ( lc ( $lexeme->text ) eq 'ifndef' ) {

    # Do nothing

  } else {

    return 0;

  }

  $lexeme = $lexeme->nextUseful;
  $lexeme = $lexeme->nextUseful if $lexeme->text eq '(';
  return 0 if $lexeme->token ne 'Identifier';
  $lexeme = $lexeme->nextUseful;
  $lexeme = $lexeme->nextUseful if $lexeme->text eq ')';
  return 0 unless $lexeme->text eq '#';
  $lexeme = $lexeme->nextUseful;
  return 0 unless lc ( $lexeme->text ) eq 'define';
  $lexeme = $lexeme->nextUseful;
  $lexeme = $lexeme->nextUseful if $lexeme->text eq '(';
  return 0 if $lexeme->token ne 'Identifier';

  # Test that the identifier is unique
  my @possibleDups = $check->db->lookup( $lexeme->text );
  return 2 if 0 + @possibleDups > 1;

  return 1;
}


# This subroutine checks for the ifdef include guard
sub includeGuardAlt {

  my $lexeme = shift;
  my $check = shift;

  if ( lc ( $lexeme->text ) eq 'if' ) {

    $lexeme = $lexeme->nextUseful;
    return 0 unless lc ( $lexeme->text ) eq 'defined';

  } elsif ( lc ( $lexeme->text ) eq 'ifdef' ) {

    # Do nothing

  } else {

    return 0;

  }

  $lexeme = $lexeme->nextUseful;
  $lexeme = $lexeme->nextUseful if $lexeme->text eq '(';
  return 0 if $lexeme->token ne 'Identifier';
  $lexeme = $lexeme->nextUseful;
  $lexeme = $lexeme->nextUseful if $lexeme->text eq ')';
  return 0 unless $lexeme->text eq '#';
  $lexeme = $lexeme->nextUseful;
  return 0 unless lc ( $lexeme->text ) eq 'error';

  while ( $lexeme and $lexeme->text ne 'else' ) {
    $lexeme = $lexeme->nextUseful;
  }

  return 0 unless $lexeme;
  $lexeme = $lexeme->nextUseful;
  return 0 unless $lexeme->text eq '#';
  $lexeme = $lexeme->nextUseful;
  return 0 unless lc ( $lexeme->text ) eq 'define';
  $lexeme = $lexeme->nextUseful;
  $lexeme = $lexeme->nextUseful if $lexeme->text eq '(';
  return 0 if $lexeme->token ne 'Identifier';
  
  # Test that the identifier is unique
  my @possibleDups = $check->db->lookup( $lexeme->text );
  return 2 if 0 + @possibleDups > 1;

  return 1;
}


# This is the actual test being performed on the user's code
sub check {

  # Pull the name of the check and the name of the file from the incoming script request
  my $check = shift; 
  my $file = shift;
  return unless $file->kind->check("file");
  return unless $file->kind->longname =~ /\bHeader\b/;
  
  # This check requires use of the Understand lexer. Initialize and check for failure 
  my $lexer = $file->lexer( 1, , 0, 1 );
  return unless $lexer;
  
  # $lexeme is initialized as the first element returned from the lexer
  my $lexeme = $lexer->first();
  
  # Special case for an empty file
  unless ( $lexeme->nextUseful ) {

    $check->violation( $lexeme->ent, $file, $lexeme->line_begin, $lexeme->column_begin, ERR1 );
    return;

  }

  # Move past all the white space and comments, test just in case no comments exist
  $lexeme = $lexeme->nextUseful unless $lexeme->text eq '#';

  # Move onto the start of the first macro
  $lexeme = $lexeme->nextUseful;

  my $dupeOne = includeGuard( $lexeme, $check );
  my $dupeTwo = includeGuardAlt( $lexeme, $check );

  # Test that the macro, if one exists, is unique
  if ( $dupeOne == 2 or $dupeTwo == 2 ) {

    $check->violation( $lexeme->ent, $file, $lexeme->line_begin, $lexeme->column_begin, ERR3 );
    return;

  }

  # Check for the approved forms of include guards
  my $passed = ( $dupeOne or $dupeTwo );
  $check->violation( $lexeme->ent, $file, $lexeme->line_begin, $lexeme->column_begin, ERR1 ) unless $passed;
  return unless $passed;

  # Check the end of the file for the second half of the include guard
  my $endOfFile = 0;
  my $finalLexeme = $lexeme;

  # Walk through the file looking for an endif
  while ( $lexeme ) {

    # If this is the last element of the file, set our flag
    if ( $lexeme->text eq 'endif' ) {
      $endOfFile = 1 unless $lexeme->nextUseful;
    }

    $finalLexeme = $lexeme;
    $lexeme = $lexeme->nextUseful;

  }
  $check->violation( $finalLexeme->ent, $file, $finalLexeme->line_begin, $finalLexeme->column_begin, ERR2 ) unless $endOfFile;
}